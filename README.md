# Модель процессорного ядра с двухадресными командами

## Описание

Проект реализует симуляцию процессора с двухадресными командами на основе **Гарвардской архитектуры**. Процессор выполняет базовые операции: загрузка данных из памяти в регистры, сохранение данных из регистров в память, арифметические операции (сложение, вычитание) и завершение программы. Модель использует раздельную память для команд и данных, что позволяет одновременно извлекать команды и работать с данными. 

### Основные компоненты
- **Processor**: симулирует процессор и выполняет команды, работая с регистрами.
- **Memory**: управляет памятью команд и данными.
- **Instruction**: представляет команды процессора.
- **Program**: основной класс для запуска программы.

## Команды процессора

Процессор поддерживает следующие команды:
- **LOAD** — загрузка данных из памяти в регистр.
- **STORE** — сохранение данных из регистра в память.
- **ADD** — сложение значений двух регистров.
- **SUB** — вычитание значений одного регистра из другого.
- **HALT** — завершение программы.

### Формат команды

Каждая команда имеет следующий формат:

```
[OpCode, Operand1, Operand2]
```

- **OpCode** — код операции (LOAD, STORE, ADD, SUB, HALT).
- **Operand1** — первый операнд (регистр).
- **Operand2** — второй операнд (регистр или адрес в памяти).

## Структура проекта

### Классы

1. **Instruction**: Класс для представления команды с кодом операции и двумя операндами.
    - Поля: `OpCode`, `Operand1`, `Operand2`
    - Методы: `ToString()` — для отображения команды в строковом формате.

2. **Memory**: Класс для управления памятью команд и данных.
    - Методы:
        - `LoadData()`: загружает массив данных в память.
        - `LoadProgram()`: загружает программу (набор команд) в память.
        - `FetchInstruction()`: извлекает команду из памяти команд.
  
3. **Processor**: Основной класс для выполнения программы.
    - Методы:
        - `ExecuteProgram()`: выполняет программу, извлекая и исполняя команды.
        - `DecodeAndExecute()`: декодирует и выполняет команды напрямую с регистрами.
  
4. **Program**: Основной класс, который инициализирует память, загружает программу и запускает процессор.

## Как использовать

1. **Инициализация данных и программы**:
    - В классе `Memory` инициализируется память данных и загружается программа в память команд.
    - Пример данных: массив целых чисел.
    - Пример программы: команды для выполнения сложения элементов массива.

2. **Запуск процессора**:
    - Процессор последовательно извлекает команды из памяти и выполняет их, изменяя состояние регистров и памяти данных.
    - Команда `HALT` завершает выполнение программы.

3. **Пример программы для суммирования элементов массива**:

```csharp
List<Instruction> program = new List<Instruction>
{
    new Instruction(1, 0, 0),  // Загрузить значение dmem[0] в R0
    new Instruction(1, 1, 1),  // Загрузить значение dmem[1] в R1
    new Instruction(3, 0, 1),  // Сложить R0 и R1, результат в R0

    new Instruction(1, 1, 2),  // Загрузить значение dmem[2] в R1
    new Instruction(3, 0, 1),  // Сложить R0 и R1, результат в R0

    new Instruction(2, 9, 0),  // Сохранить результат (R0) в dmem[9]
    new Instruction(99, 0, 0)  // Остановить выполнение программы
};
```

### Пример вывода

```
Извлечена команда (IR): [1, 0, 0]
PC: 0
Регистры: 1, 0, 0, 0, 0, 0, 0, 0
Память данных: 1, 1, 1, 1, 1, 1, 1, 1, 1, 0

Извлечена команда (IR): [1, 1, 1]
PC: 1
Регистры: 1, 1, 0, 0, 0, 0, 0, 0
Память данных: 1, 1, 1, 1, 1, 1, 1, 1, 1, 0

Извлечена команда (IR): [3, 0, 1]
PC: 2
Регистры: 2, 1, 0, 0, 0, 0, 0, 0
Память данных: 1, 1, 1, 1, 1, 1, 1, 1, 1, 0
...
```

### Ожидаемый результат:
- Итоговая сумма всех элементов массива `dmem[0] - dmem[8]` будет сохранена в `dmem[9]`.

## Как запустить проект

1. Склонируйте репозиторий или загрузите код проекта.
2. Откройте проект в Visual Studio или другой C#-совместимой IDE.
3. Запустите проект (`F5`), чтобы выполнить симуляцию процессора.

## Требования

- **C#** (совместимый с .NET Core или .NET Framework).
- **IDE**: Visual Studio, Rider или любая другая C# IDE.
