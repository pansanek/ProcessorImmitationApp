# Модель процессорного ядра с двухадресными командами

## Описание

Проект реализует симуляцию процессора с двухадресными командами на основе **Гарвардской архитектуры**. Процессор выполняет базовые операции: загрузка данных из памяти в регистры, сохранение данных из регистров в память, арифметические операции (сложение, вычитание) и завершение программы. Модель использует раздельную память для команд и данных, что позволяет одновременно извлекать команды и работать с данными. 

### Основные компоненты
- **Processor**: симулирует процессор и выполняет команды, работая с регистрами.
- **Memory**: управляет памятью команд и данными.
- **Instruction**: представляет команды процессора.
- **Program**: основной класс для запуска программы.

## Команды процессора

Процессор поддерживает следующие команды:
- **LOAD (0)** — загрузка данных из памяти в регистр. Формат команды: ```[000, регистр, адрес]```.
- **STORE (1)** — сохранение данных из регистра в память. Формат команды: ```[001, адрес, регистр]```.
- **ADD (3)** — сложение двух регистров. Формат команды: ```[010, регистр1, регистр2]```.
- **JUMP_IF (4)** — условный переход. Формат команды: ```[011, регистр1, регистр2]```.
- **JUMP (5)** — безусловный переход. Формат команды: ```[100, адрес, 0]```.
- **HALT (6)** — остановка программы. Формат команды: ```[101, 0, 0]```.
- **LOAD_SIZE (7)** — загрузка размера массива в регистр. Формат команды: ```[111, регистр, 0]```.
- **INC (8)** — увеличение значения регистра на 1. Формат команды: ```[111, регистр, 0]```.

### Формат команды

Каждая команда имеет следующий формат:

```
[cmdtype, Операнд 1, Операнд 2]
```

- **cmdtype** — код операции.
- **Операнд 1** — первый операнд.
- **Операнд 2** — второй операнд.

Каждый код операции и операнд должен быть переведен в двоичную систему счисления.
## Структура проекта

### Классы

1. **Instruction**: Класс для представления команды с кодом операции и двумя операндами.
    - Поля: `cmdtype`, `Operand1`, `Operand2`
    - Методы: `ToString()` — для отображения команды в строковом формате.

2. **Memory**: Класс для управления памятью команд и данных.
    - Методы:
        - `LoadData()`: загружает массив данных в память.
        - `LoadProgram()`: загружает программу (набор команд) в память.
        - `FetchInstruction()`: извлекает команду из памяти команд.
  
3. **Processor**: Основной класс для выполнения программы.
    - Методы:
        - `ExecuteProgram()`: выполняет программу, извлекая и исполняя команды.
        - `DecodeAndExecute()`: декодирует и выполняет команды напрямую с регистрами.
  
4. **Program**: Основной класс, который инициализирует память, загружает программу и запускает процессор.

## Как использовать

1. **Инициализация данных и программы**:
    - В классе `Memory` инициализируется память данных и загружается программа в память команд.
    - Пример данных: массив целых чисел.
    - Пример программы: команды для выполнения сложения элементов массива.

2. **Запуск процессора**:
    - Процессор последовательно извлекает команды из памяти и выполняет их, изменяя состояние регистров и памяти данных.
    - Команда `HALT` завершает выполнение программы.

3. **Пример программы для суммирования элементов массива**:

```csharp
List<uint> program = new List<uint>
{
    0b000_0001_0000u,  // LOAD R0, dmem[0]    (Загрузить первый элемент в R0)
    0b111_0010_0000u,  // INC R2              (Инициализировать счётчик позиций R2 на 1)
    0b110_0011_0000u,  // LOAD_SIZE R3        (Загрузить размер массива в R3)
    
    // Метка начала цикла
    0b000_0001_0010u,  // LOAD R1, dmem[R2]   (Загрузить текущий элемент массива в R1)
    0b010_0000_0001u,  // ADD R0, R1          (Добавить элемент к сумме)
    0b111_0010_0000u,  // INC R2              (Увеличить счётчик позиций R2 на 1)
    
    // Проверка завершения цикла
    0b011_0010_0111u,  // JUMP_IF R2 == R3    (Если R2 == R3, переход к завершению)
    0b100_0010_0000u,  // JUMP START          (Переход к началу цикла для следующего элемента)
    
    // Метка завершения программы
    0b001_1000_0000u,  // STORE R0, dmem[9]   (Сохранить сумму в dmem[9])
    0b101_0000_0000u   // HALT                (Завершить выполнение программы)
};
```

### Пример вывода

```
Извлечена команда: CmdType: 100, Operand1: 0010, Operand2: 0000
Переход
PC: 2
Регистры: 36, 8, 9, 10
Память данных: 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

Извлечена команда: CmdType: 000, Operand1: 0001, Operand2: 0010
Загрузка в 9 значение 9
PC: 3
Регистры: 36, 9, 9, 10
Память данных: 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

Извлечена команда: CmdType: 010, Operand1: 0000, Operand2: 0001
PC: 4
Регистры: 45, 9, 9, 10
Память данных: 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

Извлечена команда: CmdType: 111, Operand1: 0010, Operand2: 0000
Увеличен регистр R2 до 10
PC: 5
Регистры: 45, 9, 10, 10
Память данных: 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
...
```

### Ожидаемый результат:
- Итоговая сумма всех элементов массива `dmem[1] - dmem[n]` будет сохранена в `dmem[n+1]`.

## Как запустить проект

1. Склонируйте репозиторий или загрузите код проекта.
2. Откройте проект в Visual Studio или другой C#-совместимой IDE.
3. Запустите проект (`F5`), чтобы выполнить симуляцию процессора.

## Требования

- **C#** (совместимый с .NET Core или .NET Framework).
- **IDE**: Visual Studio, Rider или любая другая C# IDE.
